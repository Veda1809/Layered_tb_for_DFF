# LAYERED_TB_FOR_DFF
## Objective
The objective is to write a layered testbench for a **Asynchronous D Flip-Flop** and to verify its functionality by generating different types of input stimulus and also to find the functional coverage.
# TABLE OF CONTENTS
+ [INTRODUCTION](#introduction)
+ [DESIGN](#design)
+ [TRANSACTION CLASS](#transaction-class)
+ [GENERATOR CLASS](#generator-class)
+ [DRIVER CLASS](#driver-class)
+ [INTERFACE](#interface)
+ [MONITOR CLASS](#monitor-class)
+ [SCOREBOARD](#scoreboard)
+ [ENVIRONMENT CLASS](#environment-class)
+ [TEST](#test)
+ [TESTBENCH](#testbench)
+ [CONCLUSION](#conclusion)

# Introduction
+ Testbench is used to check the functional correctness of the Design Under Test (DUT) by generating and driving a predefined input sequence to a design, capturing the design output and comparing with-respect-to expected output.
+ SystemVerilog has something different than the normal testbenches, called a ‘Layered Testbench’. The overall idea behind a layered testbench is to create an environment that is easy to adopt, follow and verify.
+ A testbench in SystemVerilog is layered because the process of verification is distributed into segments, each performing different tasks.

<img width="421" alt="image" src="https://github.com/Veda1809/Layered_tb_for_DFF/assets/142098395/f2c233ee-3992-410f-b8d4-bef3669d5b34">

# Design
## ASYNCHRONOUS D-FLIP FLOP
- A flip-flop is the fundamental sequential circuit element, which has two stable
states and can store one bit at a time. D flip- flop is one of that flip-flop that can
store data.
- D flip-flop can have an asynchronous rest as input independent of the clock. That
means the output of the flip-flop can be set to 0 with the reset despite the clock
pulse, which means the output can change with or without the clock, which can
result in asynchronous output.

<img width="353" alt="image" src="https://github.com/Veda1809/Layered_tb_for_DFF/assets/142098395/241ef51e-0748-4d25-881a-a22c9ed9b410">

# Transaction Class
- All the input and the output signals available in the design are declared here. 
- The inputs are declared rand. 
# Generator Class
- It is a class, where the input signals are randomized.
- The randomized inputs are put into the mailbox using the put method.
- It generated the stimulus required for the DUT. The stimulus is sent to the DUT via driver.
- Thus, the data is first received by the class driver.
- The exchange of data form one class to another can be done using Mailbox.
# Driver Class
- It drives the stimulus to the DUT. It receives the data from the Generator via Mailbox.
- It converts the data in the form of inputs to the DUT and passes on to the DUT.
# Interface
- It is a bunch of signals that connect the TB to RTL, DUT – RTL.
- Here a virtual interface is used since class is dynamic in nature and interface is static in nature.
# Monitor Class
- It is a class which observes the activity on the interface signals.
- The outputs that are generated by the DUT after receiving the stimulus, are sampled/ collected in the monitor.
# Scoreboard
It is where the comparison between the expected data and the actual data takes place, hence it is called as comparator.
# Environment Class
It contains instances of the generator, driver, monitor, and scoreboard, connects generators to drivers and monitors to scoreboard with mailboxes, and provides instance of the interface to all.
# Test
It is a module that instantiates the environment and calls its run() procedure.
# Testbench
- It is the top level entity and a module . 
- Instantiates the DUT, interface and the test
# Conclusion
<img width="240" alt="image" src="https://github.com/Veda1809/Layered_tb_for_DFF/assets/142098395/78bbfa28-f0b6-4814-a6ca-ec63fada5abb">

+ The result is as expected, hence the testbench has successfully been run. This means that the output of the DUT and the output of the reference model are matching.
+ And also we can see that the functional coverage is also 100%.
